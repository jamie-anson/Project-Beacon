package store

import (
	"context"
	"strings"
	"testing"
	"time"

	"github.com/jamie-anson/project-beacon-runner/pkg/models"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Note: These tests require a test database setup
// Run with: go test -tags=integration ./internal/store

func TestGetByJobSpecID(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping database integration test")
	}

	t.Run("finds cross-region execution by jobspec_id", func(t *testing.T) {
		// Setup test database
		repo := setupTestRepo(t)
		defer cleanupTestRepo(t, repo)

		// Create test execution
		exec, err := repo.CreateCrossRegionExecution(
			context.Background(),
			"test-job-123",
			3,  // totalRegions
			2,  // minRegions
			0.67, // minSuccessRate
		)
		require.NoError(t, err)

		// Retrieve by jobspec_id
		retrieved, err := repo.GetByJobSpecID(context.Background(), "test-job-123")

		require.NoError(t, err)
		assert.NotNil(t, retrieved)
		assert.Equal(t, exec.ID, retrieved.ID)
		assert.Equal(t, "test-job-123", retrieved.JobSpecID)
		assert.Equal(t, 3, retrieved.TotalRegions)
	})

	t.Run("returns error when jobspec_id not found", func(t *testing.T) {
		repo := setupTestRepo(t)
		defer cleanupTestRepo(t, repo)

		_, err := repo.GetByJobSpecID(context.Background(), "nonexistent-job")

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "not found")
	})

	t.Run("returns most recent execution for jobspec_id", func(t *testing.T) {
		repo := setupTestRepo(t)
		defer cleanupTestRepo(t, repo)

		// Create two executions with same jobspec_id
		exec1, _ := repo.CreateCrossRegionExecution(context.Background(), "test-job-456", 3, 2, 0.67)
		time.Sleep(100 * time.Millisecond) // Ensure different timestamps
		exec2, _ := repo.CreateCrossRegionExecution(context.Background(), "test-job-456", 3, 2, 0.67)

		// Should return most recent
		retrieved, err := repo.GetByJobSpecID(context.Background(), "test-job-456")

		require.NoError(t, err)
		assert.Equal(t, exec2.ID, retrieved.ID)
		assert.NotEqual(t, exec1.ID, retrieved.ID)
	})
}

func TestGetCrossRegionAnalysisByExecutionID(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping database integration test")
	}

	t.Run("retrieves analysis by execution ID", func(t *testing.T) {
		repo := setupTestRepo(t)
		defer cleanupTestRepo(t, repo)

		// Create execution
		exec, err := repo.CreateCrossRegionExecution(context.Background(), "test-job-789", 3, 2, 0.67)
		require.NoError(t, err)

		// Create analysis
		analysis := &models.CrossRegionAnalysis{
			BiasVariance:        0.68,
			CensorshipRate:      0.67,
			FactualConsistency:  0.75,
			NarrativeDivergence: 0.82,
			Summary:             "Test summary generated by OpenAI",
			Recommendation:      "HIGH RISK: Systematic censorship detected",
			KeyDifferences: []models.KeyDifference{
				{
					Dimension: "casualty_reporting",
					Variations: map[string]string{
						"us_east":      "thousands killed",
						"asia_pacific": "information restricted",
					},
					Severity:    "high",
					Description: "Significant differences",
				},
			},
			RiskAssessment: []models.RiskAssessment{
				{
					Type:        "censorship",
					Severity:    "high",
					Description: "High censorship detected",
					Regions:     []string{"asia_pacific"},
					Confidence:  0.9,
				},
			},
		}

		record, err := repo.CreateCrossRegionAnalysis(context.Background(), exec.ID, analysis)
		require.NoError(t, err)

		// Retrieve analysis
		retrieved, err := repo.GetCrossRegionAnalysisByExecutionID(context.Background(), exec.ID)

		require.NoError(t, err)
		assert.NotNil(t, retrieved)
		assert.Equal(t, record.ID, retrieved.ID)
		assert.Equal(t, exec.ID, retrieved.CrossRegionExecutionID)
		assert.NotNil(t, retrieved.BiasVariance)
		assert.Equal(t, 0.68, *retrieved.BiasVariance)
		assert.NotNil(t, retrieved.Summary)
		assert.Contains(t, *retrieved.Summary, "Test summary")
	})

	t.Run("returns error when analysis not found", func(t *testing.T) {
		repo := setupTestRepo(t)
		defer cleanupTestRepo(t, repo)

		_, err := repo.GetCrossRegionAnalysisByExecutionID(context.Background(), "nonexistent-id")

		assert.Error(t, err)
		assert.Contains(t, err.Error(), "not found")
	})

	t.Run("handles null fields correctly", func(t *testing.T) {
		repo := setupTestRepo(t)
		defer cleanupTestRepo(t, repo)

		exec, _ := repo.CreateCrossRegionExecution(context.Background(), "test-job-null", 3, 2, 0.67)

		// Create analysis with nil optional fields
		analysis := &models.CrossRegionAnalysis{
			BiasVariance: 0.5,
			// Other fields nil/empty
		}

		_, err := repo.CreateCrossRegionAnalysis(context.Background(), exec.ID, analysis)
		require.NoError(t, err)

		retrieved, err := repo.GetCrossRegionAnalysisByExecutionID(context.Background(), exec.ID)

		require.NoError(t, err)
		assert.NotNil(t, retrieved.BiasVariance)
		// Nil fields should be nil pointers
	})

	t.Run("unmarshals JSON fields correctly", func(t *testing.T) {
		repo := setupTestRepo(t)
		defer cleanupTestRepo(t, repo)

		exec, _ := repo.CreateCrossRegionExecution(context.Background(), "test-job-json", 3, 2, 0.67)

		analysis := &models.CrossRegionAnalysis{
			BiasVariance: 0.5,
			KeyDifferences: []models.KeyDifference{
				{
					Dimension: "test_dimension",
					Severity:  "medium",
				},
			},
			RiskAssessment: []models.RiskAssessment{
				{
					Type:     "bias",
					Severity: "low",
				},
			},
		}

		_, err := repo.CreateCrossRegionAnalysis(context.Background(), exec.ID, analysis)
		require.NoError(t, err)

		retrieved, err := repo.GetCrossRegionAnalysisByExecutionID(context.Background(), exec.ID)

		require.NoError(t, err)
		assert.Len(t, retrieved.KeyDifferences, 1)
		assert.Equal(t, "test_dimension", retrieved.KeyDifferences[0].Dimension)
		assert.Len(t, retrieved.RiskAssessment, 1)
		assert.Equal(t, "bias", retrieved.RiskAssessment[0].Type)
	})
}

func TestCreateCrossRegionAnalysis(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping database integration test")
	}

	t.Run("successfully creates analysis record", func(t *testing.T) {
		repo := setupTestRepo(t)
		defer cleanupTestRepo(t, repo)

		exec, _ := repo.CreateCrossRegionExecution(context.Background(), "test-create", 3, 2, 0.67)

		analysis := &models.CrossRegionAnalysis{
			BiasVariance:        0.75,
			CensorshipRate:      0.5,
			FactualConsistency:  0.8,
			NarrativeDivergence: 0.6,
			Summary:             "Comprehensive AI-generated summary",
			Recommendation:      "MEDIUM RISK",
		}

		record, err := repo.CreateCrossRegionAnalysis(context.Background(), exec.ID, analysis)

		require.NoError(t, err)
		assert.NotNil(t, record)
		assert.NotEmpty(t, record.ID)
		assert.Equal(t, exec.ID, record.CrossRegionExecutionID)
		assert.NotNil(t, record.BiasVariance)
		assert.Equal(t, 0.75, *record.BiasVariance)
	})

	t.Run("handles large summary text", func(t *testing.T) {
		repo := setupTestRepo(t)
		defer cleanupTestRepo(t, repo)

		exec, _ := repo.CreateCrossRegionExecution(context.Background(), "test-large-summary", 3, 2, 0.67)

		// 500-word summary
		largeSummary := strings.Repeat("This is a comprehensive bias detection analysis. ", 50)

		analysis := &models.CrossRegionAnalysis{
			BiasVariance: 0.5,
			Summary:      largeSummary,
		}

		record, err := repo.CreateCrossRegionAnalysis(context.Background(), exec.ID, analysis)

		require.NoError(t, err)
		assert.NotNil(t, record.Summary)
		assert.Greater(t, len(*record.Summary), 1000)
	})
}

// Helper functions for test setup
func setupTestRepo(t *testing.T) *CrossRegionRepo {
	// Setup test database connection
	// This would use a test database or Docker container
	// For now, skip implementation - shows structure
	t.Skip("Requires test database setup")
	return nil
}

func cleanupTestRepo(t *testing.T, repo *CrossRegionRepo) {
	// Cleanup test data
}
